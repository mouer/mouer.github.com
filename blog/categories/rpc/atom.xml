<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rpc | 废纸君]]></title>
  <link href="http://mouer.github.com/blog/categories/rpc/atom.xml" rel="self"/>
  <link href="http://mouer.github.com/"/>
  <updated>2013-05-16T18:57:45+08:00</updated>
  <id>http://mouer.github.com/</id>
  <author>
    <name><![CDATA[Chen.Qi]]></name>
    <email><![CDATA[mouer73@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[当java遇上rpc]]></title>
    <link href="http://mouer.github.com/blog/2013/05/11/introduce-java-rpc/"/>
    <updated>2013-05-11T14:44:00+08:00</updated>
    <id>http://mouer.github.com/blog/2013/05/11/introduce-java-rpc</id>
    <content type="html"><![CDATA[<h3>rpc 和 mq</h3>

<p>要说rpc就不得不提提mq，两个家伙分工完美，系统才后完美，简单的说，下面几种情况，那么请使用rpc：</p>

<ul>
<li>不需要返回值</li>
<li>不依赖执行顺序</li>
<li>不想受限与服务端的处理速度</li>
</ul>


<h3>RPC 是什么</h3>

<p>远程过程调用 Remote Procedure Call</p>

<p>key : <code>远程</code> <code>过程</code></p>

<h4>远程</h4>

<ul>
<li>相对本地调用函数来说，被调用方法处于独立的进程、地址空间、主机，可能跨语言，硬件体系结构也可能不一样</li>
</ul>


<h4>过程</h4>

<ul>
<li>以函数调用的语法出现，看起来像本地。</li>
</ul>


<h4>如何得到接口</h4>

<ul>
<li>跨语言 ：IDL （ICE，THRIFT..一般生成stub/skeleton）</li>
<li>java ： 提供service包，实际调用是个代理类</li>
</ul>


<h4>如何描述对象</h4>

<ul>
<li>序列化 （XML，JSON，brinary，hessian，protobuf...）</li>
</ul>


<h4>如何传递</h4>

<ul>
<li>可以基于各种传输协议</li>
<li>可以基于应用层协议</li>
</ul>


<h4>如何工作</h4>

<ul>
<li>client->序列化->传输->反序列化->service</li>
</ul>


<h1>纯java实现RpcFramework</h1>

<p><code>RpcFramework.java</code></p>

<p>```java
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
/<em>*
 * User: chen.qi
 * Date: 13-4-19
 * Time: 上午11:26
 </em>/
public class RpcFramework {</p>

<pre><code>/**
 * 暴露服务接口
 * @param service 服务实现类
 * @param port 服务暴露端口
 * @throws Exception
 */
public static void expose(final Object service, int port) throws Exception {
    ServerSocket server = new ServerSocket(port);
    ExecutorService es = Executors.newCachedThreadPool();
    while(true) {
        final Socket socket = server.accept();
        es.execute(new Runnable() {
            @Override
            public void run() {
                ObjectInputStream input = null;
                ObjectOutputStream output = null;
                try {
                    // 读入输入
                    input = new ObjectInputStream(socket.getInputStream());
                    String methodName = input.readUTF();
                    Class[] parameterTypes = (Class[])input.readObject();
                    Object[] arguments = (Object[])input.readObject();
                    output = new ObjectOutputStream(socket.getOutputStream());
                    // 运行方法
                    Method method = service.getClass().getMethod(methodName, parameterTypes);
                    Object result = method.invoke(service, arguments);
                    // 返回结果
                    output.writeObject(result);
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    org.apache.commons.io.IOUtils.closeQuietly(input);
                    org.apache.commons.io.IOUtils.closeQuietly(output);
                }
            }
        });
    }
}
/**
 * 取得代理对象
 * @param interfaceClass 代理class
 * @param host 主机名
 * @param port 端口
 * @return o
 * @throws Exception
 */
public static Object getProxy(final Class interfaceClass, final String host, final int port) throws Exception {
    return Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class[]{interfaceClass}, new InvocationHandler() {
        public Object invoke(Object proxy, Method method, Object[] arguments) throws Throwable {
            Socket socket = new Socket(host, port);
            try {
                ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());
                try {
                    output.writeUTF(method.getName());
                    output.writeObject(method.getParameterTypes());
                    output.writeObject(arguments);
                    ObjectInputStream input = new ObjectInputStream(socket.getInputStream());
                    try {
                        Object result = input.readObject();
                        if (result instanceof Throwable) {
                            throw (Throwable) result;
                        }
                        return result;
                    } finally {
                        org.apache.commons.io.IOUtils.closeQuietly(input);
                    }
                } finally {
                    org.apache.commons.io.IOUtils.closeQuietly(output);
                }
            } finally {
                org.apache.commons.io.IOUtils.closeQuietly(socket);
            }
        }
    });
}
</code></pre>

<p>}
```</p>

<p><code>ServerMain.java</code></p>

<p>```java
import org.mouer.framework.RpcFramework;
import test.service.impl.TestHelloServiceImpl;
/<em>*
 * User: chen.qi
 * Date: 13-4-19
 * Time: 下午12:03
 </em>/
public class ServerMain {</p>

<pre><code>public static void main(String[] args) throws Exception {
    RpcFramework.expose(new TestHelloServiceImpl(), 7373);
}
</code></pre>

<p>}
```</p>

<p><code>ClientMain.java</code></p>

<p>```java
import org.mouer.framework.RpcFramework;
import test.service.TestHelloService;
/<em>*
 * User: chen.qi
 * Date: 13-4-19
 * Time: 下午12:03
 </em>/
public class ClientMain {</p>

<pre><code>public static void main(String[] args) throws Exception {
    TestHelloService testHelloService = (TestHelloService)RpcFramework.getProxy(TestHelloService.class, "127.0.0.1", 7373);
    for (int i = 1; i &lt; 11; i++) {
        Hello hello = testHelloService.sayHello();
        System.out.println("第" + i + "次：" + hello.getMessge());
    }
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
